{"version":3,"sources":["../src/index.mts","../src/as-absolute-path.mts","../src/asset-files.mts"],"sourcesContent":["import * as webFetch from \"@remix-run/web-fetch\"\r\n\r\n// only override the File global\r\n// if we override everything else, we get errors caused by the mismatch of built-in types and remix types\r\nglobal.File = webFetch.File\r\n\r\nimport { constants, access, watch } from \"node:fs/promises\"\r\nimport type { AppLoadContext, ServerBuild } from \"@remix-run/node\"\r\nimport { broadcastDevReady, createRequestHandler } from \"@remix-run/node\"\r\nimport { app, protocol } from \"electron\"\r\nimport { asAbsolutePath } from \"./as-absolute-path.mjs\"\r\nimport { serveAsset } from \"./asset-files.mjs\"\r\n\r\nconst getDefaultMode = () =>\r\n\tapp.isPackaged ? \"production\" : process.env.NODE_ENV\r\n\r\ntype MaybePromise<T> = Promise<T> | T\r\n\r\ntype GetLoadContextFunction = (\r\n\trequest: Request,\r\n) => MaybePromise<AppLoadContext | undefined>\r\n\r\ninterface InitRemixOptions {\r\n\tserverBuild: ServerBuild | string\r\n\tmode?: string\r\n\tpublicFolder?: string\r\n\taltPublicFolder?: string,\r\n\taltFilePrefix?: string,\r\n\taltURLTransformer?: (s: string) => string,\r\n\tgetLoadContext?: GetLoadContextFunction\r\n\tesm?: boolean\r\n}\r\n\r\n/**\r\n * Initialize and configure remix-electron\r\n *\r\n * @param options\r\n * @returns The url to use to access the app.\r\n */\r\nexport async function initRemix({\r\n\tserverBuild: serverBuildOption,\r\n\tmode,\r\n\tpublicFolder: publicFolderOption = \"public\",\r\n\taltPublicFolder,\r\n\taltFilePrefix,\r\n\taltURLTransformer,\r\n\tgetLoadContext,\r\n\tesm = typeof require === \"undefined\",\r\n}: InitRemixOptions): Promise<string> {\r\n\tconst publicFolder = asAbsolutePath(publicFolderOption, process.cwd())\r\n\r\n\tif (\r\n\t\t!(await access(publicFolder, constants.R_OK).then(\r\n\t\t\t() => true,\r\n\t\t\t() => false,\r\n\t\t))\r\n\t) {\r\n\t\tthrow new Error(\r\n\t\t\t`Public folder ${publicFolder} does not exist. Make sure that the initRemix \\`publicFolder\\` option is configured correctly.`,\r\n\t\t)\r\n\t}\r\n\r\n\tconst buildPath =\r\n\t\ttypeof serverBuildOption === \"string\" ? serverBuildOption : undefined\r\n\r\n\tlet serverBuild =\r\n\t\ttypeof buildPath === \"string\"\r\n\t\t\t? /** @type {ServerBuild} */ await import(\r\n\t\t\t\t\tesm ? `${buildPath}?${Date.now()}` : buildPath\r\n\t\t\t\t)\r\n\t\t\t: serverBuildOption\r\n\r\n\tawait app.whenReady()\r\n\r\n\tprotocol.handle(\"http\", async (request) => {\r\n\t\tconst url = new URL(request.url)\r\n\t\tif (\r\n\t\t\t// We only want to handle local (Remix) requests to port 80.\r\n\t\t\t// Requests to other hosts or ports should not be intercepted,\r\n\t\t\t// this might be the case when an application makes requests to a local service.\r\n\t\t\t![\"localhost\", \"127.0.0.1\"].includes(url.hostname) ||\r\n\t\t\t(url.port && url.port !== \"80\")\r\n\t\t) {\r\n\t\t\treturn await fetch(request)\r\n\t\t}\r\n\r\n\t\trequest.headers.append(\"Referer\", request.referrer)\r\n\t\ttry {\r\n\t\t\tconst assetResponse = await serveAsset(request, publicFolder, altPublicFolder, altFilePrefix, altURLTransformer)\r\n\t\t\tif (assetResponse) {\r\n\t\t\t\treturn assetResponse\r\n\t\t\t}\r\n\r\n\t\t\tconst context = await getLoadContext?.(request)\r\n\t\t\tconst handleRequest = createRequestHandler(\r\n\t\t\t\tserverBuild,\r\n\t\t\t\tmode ?? getDefaultMode(),\r\n\t\t\t)\r\n\t\t\treturn await handleRequest(request, context)\r\n\t\t} catch (error) {\r\n\t\t\tconsole.warn(\"[remix-electron]\", error)\r\n\t\t\tconst { stack, message } = toError(error)\r\n\t\t\treturn new Response(`<pre>${stack || message}</pre>`, {\r\n\t\t\t\tstatus: 500,\r\n\t\t\t\theaders: { \"content-type\": \"text/html\" },\r\n\t\t\t})\r\n\t\t}\r\n\t})\r\n\r\n\tif (\r\n\t\t(mode ?? getDefaultMode()) !== \"production\" &&\r\n\t\ttypeof buildPath === \"string\"\r\n\t) {\r\n\t\tvoid (async () => {\r\n\t\t\tfor await (const _event of watch(buildPath)) {\r\n\t\t\t\tif (esm) {\r\n\t\t\t\t\tserverBuild = await import(`${buildPath}?${Date.now()}`)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpurgeRequireCache(buildPath)\r\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n\t\t\t\t\tserverBuild = require(buildPath)\r\n\t\t\t\t}\r\n\t\t\t\tawait broadcastDevReady(serverBuild)\r\n\t\t\t}\r\n\t\t})()\r\n\t}\r\n\r\n\t// the remix web socket reads the websocket host from the browser url,\r\n\t// so this _has_ to be localhost\r\n\treturn \"http://localhost/\"\r\n}\r\n\r\nfunction purgeRequireCache(prefix: string) {\r\n\tfor (const key in require.cache) {\r\n\t\tif (key.startsWith(prefix)) {\r\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-dynamic-delete\r\n\t\t\tdelete require.cache[key]\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction toError(value: unknown) {\r\n\treturn value instanceof Error ? value : new Error(String(value))\r\n}\r\n","import path from \"node:path\"\r\n\r\nexport function asAbsolutePath(filePath: string, workingDirectory: string) {\r\n\treturn path.isAbsolute(filePath)\r\n\t\t? filePath\r\n\t\t: path.join(workingDirectory, filePath)\r\n}\r\n","import fs from \"node:fs\"\r\nimport path from \"node:path\"\r\nimport { createReadableStreamFromReadable } from \"@remix-run/node\"\r\nimport mime from \"mime\"\r\n\r\nexport async function serveAsset(\r\n\trequest: Request,\r\n\tpublicFolder: string,\r\n\taltPublicFolder?: string,\r\n\taltFilePrefix?: string,\r\n\taltURLTransformer?: (s: string) => string\r\n): Promise<Response | undefined> {\r\n\tconst url = new URL(request.url)\r\n\tconst fullFilePath = !altPublicFolder || !altFilePrefix || !decodeURIComponent(url.pathname).startsWith(altFilePrefix) ?\r\n\t\tpath.join(publicFolder, decodeURIComponent(url.pathname)) :\r\n\t\tpath.join(altPublicFolder, altURLTransformer ? altURLTransformer(decodeURIComponent(url.pathname)) : decodeURIComponent(url.pathname))\r\n\tif (!fullFilePath.startsWith(publicFolder) && (!altPublicFolder || !fullFilePath.startsWith(altPublicFolder))) return\r\n\r\n\tconst stat = await fs.promises.stat(fullFilePath).catch(() => undefined)\r\n\tif (!stat?.isFile()) return\r\n\r\n\tconst headers = new Headers()\r\n\r\n\tconst mimeType = mime.getType(fullFilePath)\r\n\tif (mimeType) headers.set(\"Content-Type\", mimeType)\r\n\r\n\tconst stream = createReadableStreamFromReadable(\r\n\t\tfs.createReadStream(fullFilePath),\r\n\t)\r\n\r\n\treturn new Response(stream, {\r\n\t\theaders,\r\n\t})\r\n}\r\n"],"mappings":"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","names":["import_node","path","import_node_path","path","fs","mime"]}